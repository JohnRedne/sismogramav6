# -*- coding: utf-8 -*-
"""Untitled38.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n3hZVODY1j0YBp92DusSLEoq2h68dyrP
"""

from flask import Flask, request, jsonify, send_file
import urllib.request
import io
from obspy import read, UTCDateTime
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta
import os

app = Flask(__name__)

# Función para convertir una fecha ISO8601 a día juliano
def date_to_julian_day(date: str) -> int:
    """Convierte una fecha ISO8601 al día juliano del año."""
    dt = datetime.fromisoformat(date)
    start_of_year = datetime(dt.year, 1, 1)
    julian_day = (dt - start_of_year).days + 1
    return julian_day

@app.route('/generate_sismograma', methods=['GET'])
def generate_sismograma():
    try:
        # Obtener parámetros de la solicitud
        start_date_input = request.args.get("start")
        end_date_input = request.args.get("end")
        net = request.args.get("net")
        sta = request.args.get("sta")

        # Canal fijo
        channel = "HNE.D"
        color = "blue"

        # Validar los parámetros
        if not all([start_date_input, end_date_input, net, sta]):
            return jsonify({"error": "Faltan parámetros requeridos (start, end, net, sta)."}), 400

        # Validar formato de las fechas
        try:
            start_date = datetime.fromisoformat(start_date_input)
            end_date = datetime.fromisoformat(end_date_input)
        except ValueError:
            return jsonify({"error": "El formato de la fecha debe ser ISO8601 (ej: 2024-12-30T21:01:00)."}), 400

        # Ajustar si las horas son iguales
        if start_date == end_date:
            start_date += timedelta(seconds=20)
            end_date -= timedelta(seconds=10)

        # Limitar el intervalo a 15 minutos
        if (end_date - start_date) > timedelta(minutes=15):
            end_date = start_date + timedelta(minutes=15)

        # Convertir fecha de inicio al día juliano
        julian_day = date_to_julian_day(start_date.isoformat())
        year = start_date.year

        # Construir la URL del archivo MiniSEED
        url = f"http://osso.univalle.edu.co/apps/seiscomp/archive/{year}/{net}/{sta}/{channel}/{net}.{sta}.00.{channel}.{year}.{julian_day}"

        # Descargar y leer el archivo MiniSEED
        try:
            print(f"Descargando datos desde: {url}")
            response = urllib.request.urlopen(url)
            stream = read(io.BytesIO(response.read()))
        except Exception as e:
            print(f"Error al descargar o procesar datos para {channel}: {e}")
            return jsonify({"error": f"No se pudo procesar el canal {channel}: {e}"}), 500

        # Crear variable para la fecha
        date_str = start_date.strftime('%b-%d-%Y')

        # Graficar los datos del sismograma
        fig, ax = plt.subplots(figsize=(12, 6))

        # Convertir fechas de recorte a UTCDateTime
        start_utc = UTCDateTime(start_date)
        end_utc = UTCDateTime(end_date)

        # Recortar los datos al intervalo definido por el usuario
        stream = stream.slice(starttime=start_utc, endtime=end_utc)
        trace = stream[0]

        ax.plot(trace.times("matplotlib"), trace.data, label=f"Canal {channel}", linewidth=0.8, color=color)
        ax.set_title(f"Sismograma {channel} ({trace.stats.station})", fontsize=12)
        ax.set_xlabel("Tiempo (HH:MM:SS UTC)", fontsize=10)
        ax.set_ylabel("Amplitud", fontsize=10)
        ax.legend(loc="upper right")
        ax.grid(True, linestyle="--", alpha=0.7)

        # Formatear el eje X para mostrar tiempos en UTC
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S UTC'))

        # Mostrar el URL asociado debajo del gráfico
        plt.figtext(0.5, -0.1, f"URL ({channel}): {url}", wrap=True, horizontalalignment='center', fontsize=10, color=color)

        # Mostrar la fecha debajo del sismograma
        plt.figtext(0.5, -0.05, f"Fecha: {date_str}", wrap=True, horizontalalignment='center', fontsize=12)

        # Guardar la imagen en memoria
        output_image = io.BytesIO()
        plt.savefig(output_image, format='png', bbox_inches="tight")
        output_image.seek(0)
        plt.close(fig)

        return send_file(output_image, mimetype='image/png')

    except Exception as e:
        print(f"Error general: {e}")
        return jsonify({"error": f"Ocurrió un error durante el procesamiento: {str(e)}"}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)