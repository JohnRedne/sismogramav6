# -*- coding: utf-8 -*-
"""Untitled38.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n3hZVODY1j0YBp92DusSLEoq2h68dyrP
"""

from flask import Flask, request, jsonify, send_file
import requests
import io
from obspy import read, UTCDateTime
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta
import os

app = Flask(__name__)

# Función para convertir una fecha ISO8601 a día juliano
def date_to_julian_day(date: str) -> int:
    """Convierte una fecha ISO8601 al día juliano del año."""
    dt = datetime.fromisoformat(date.replace("Z", ""))  # Remueve la 'Z' de formato UTC
    start_of_year = datetime(dt.year, 1, 1)
    return (dt - start_of_year).days + 1

@app.route('/generate_sismograma', methods=['GET'])
def generate_sismograma():
    try:
        # Obtener parámetros de la solicitud
        start_date_input = request.args.get("start")
        end_date_input = request.args.get("end")
        net = request.args.get("net")
        sta = request.args.get("sta")

        # Canal fijo
        channel = "HNE.D"

        # Validar los parámetros
        if not all([start_date_input, end_date_input, net, sta]):
            return jsonify({"error": "Faltan parámetros requeridos (start, end, net, sta)."}), 400

        # Convertir fechas a UTC
        start_date = datetime.fromisoformat(start_date_input.replace("Z", ""))
        end_date = datetime.fromisoformat(end_date_input.replace("Z", ""))

        # Ajustar si las horas son iguales
        if start_date == end_date:
            start_date += timedelta(seconds=20)
            end_date -= timedelta(seconds=10)

        # Limitar el intervalo a 15 minutos
        if (end_date - start_date) > timedelta(minutes=15):
            end_date = start_date + timedelta(minutes=15)

        # Convertir fecha de inicio al día juliano
        julian_day = date_to_julian_day(start_date.isoformat())
        year = start_date.year

        # Construir la URL del archivo MiniSEED
        url = f"http://osso.univalle.edu.co/apps/seiscomp/archive/{year}/{net}/{sta}/{channel}/{net}.{sta}.00.{channel}.{year}.{julian_day}"

        print(f"Descargando datos desde: {url}")

        # Descargar y leer el archivo MiniSEED
        try:
            response = requests.get(url, stream=True, timeout=120)

            if response.status_code != 200:
                return jsonify({"error": f"Error {response.status_code} al descargar MiniSEED."}), 500
            
            stream = read(io.BytesIO(response.content))

        except requests.exceptions.RequestException as e:
            return jsonify({"error": f"No se pudo descargar MiniSEED: {str(e)}"}), 500

        # Crear variable para la fecha en formato Nov-11-2024
        date_str = start_date.strftime('%b-%d-%Y')

        # Graficar el sismograma
        fig, ax = plt.subplots(figsize=(12, 6))

        # Convertir fechas de recorte a UTCDateTime
        start_utc = UTCDateTime(start_date.isoformat() + "Z")
        end_utc = UTCDateTime(end_date.isoformat() + "Z")

        # Recortar datos
        stream = stream.slice(starttime=start_utc, endtime=end_utc)
        trace = stream[0]

        ax.plot(trace.times("matplotlib"), trace.data, label=f"Canal {channel}", linewidth=0.8, color="blue")
        ax.set_title(f"Sismograma {channel} ({trace.stats.station})", fontsize=12)
        ax.set_xlabel("Tiempo (HH:MM:SS UTC)", fontsize=10)
        ax.set_ylabel("Amplitud", fontsize=10)
        ax.legend(loc="upper right")
        ax.grid(True, linestyle="--", alpha=0.7)

        # Formatear el eje X para mostrar tiempos en UTC
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S UTC'))

        # Mostrar la fecha debajo del sismograma
        plt.figtext(0.5, -0.05, f"Fecha: {date_str}", wrap=True, horizontalalignment='center', fontsize=12)

        # Guardar la imagen en memoria
        output_image = io.BytesIO()
        plt.savefig(output_image, format='png', bbox_inches="tight")
        output_image.seek(0)
        plt.close(fig)

        return send_file(output_image, mimetype='image/png')

    except Exception as e:
        print(f"Error general: {e}")
        return jsonify({"error": f"Ocurrió un error: {str(e)}"}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)



