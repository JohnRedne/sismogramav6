# -*- coding: utf-8 -*-
"""Untitled38.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n3hZVODY1j0YBp92DusSLEoq2h68dyrP
"""

from flask import Flask, request, jsonify, send_file
import requests
import io
from obspy import read, UTCDateTime
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime, timedelta
import os
from flask_cors import CORS  # Habilitar CORS para evitar bloqueos en Flutter

app = Flask(__name__)
CORS(app)  # 游댳 Permitir solicitudes desde cualquier origen (Flutter)

# 游댳 **Funci칩n para convertir una fecha en d칤a juliano**
def date_to_julian_day(date: datetime) -> int:
    """Convierte una fecha en el d칤a juliano del a침o."""
    start_of_year = datetime(date.year, 1, 1)
    return (date - start_of_year).days + 1

# 游댳 **Ruta ra칤z para verificar que el backend funciona**
@app.route('/')
def home():
    return jsonify({"message": "El backend est치 funcionando correctamente"}), 200

# 游댳 **Ruta principal para generar el sismograma**
@app.route('/generate_sismograma', methods=['GET'])
def generate_sismograma():
    try:
        # 游늷 **1. Extraer los par치metros enviados desde la app Flutter (`url_build.dart`)**
        start_date_input = request.args.get("start")  # Fecha inicio
        end_date_input = request.args.get("end")      # Fecha fin
        net = request.args.get("net")                 # Red (ej. UX)
        sta = request.args.get("sta")                 # Estaci칩n (ej. UIS01)

        # 游늷 **2. Definir el canal de datos**
        channel = "HNE.D"  # Canal fijo por ahora
        color = "blue"

        # 游늷 **3. Validar que todos los par치metros existen**
        if not all([start_date_input, end_date_input, net, sta]):
            return jsonify({"error": "Faltan par치metros requeridos (start, end, net, sta)."}), 400

        # 游늷 **4. Convertir fechas ISO8601 a formato `datetime`**
        try:
            start_date = datetime.strptime(start_date_input, "%Y-%m-%dT%H:%M:%SZ")
            end_date = datetime.strptime(end_date_input, "%Y-%m-%dT%H:%M:%SZ")
        except ValueError:
            return jsonify({"error": "El formato de la fecha debe ser ISO8601 (ej: 2024-12-30T21:01:00Z)."}), 400

        # 游늷 **5. Ajustar si las horas son iguales (evita errores en la consulta)**
        if start_date == end_date:
            start_date += timedelta(seconds=20)
            end_date += timedelta(minutes=1)  # Ajustar 1 minuto

        # 游늷 **6. Limitar el intervalo m치ximo a 15 minutos**
        if (end_date - start_date) > timedelta(minutes=15):
            end_date = start_date + timedelta(minutes=15)

        # 游늷 **7. Convertir fecha de inicio a d칤a juliano**
        julian_day = date_to_julian_day(start_date)
        year = start_date.year

        # 游늷 **8. Construcci칩n de la URL para OSSO**
        osso_url = f"http://osso.univalle.edu.co/apps/seiscomp/archive/{year}/{net}/{sta}/{channel}/{net}.{sta}.00.{channel}.{year}.{julian_day}"

        print(f"游댳 Descargando datos desde: {osso_url}")

        # 游늷 **9. Descargar los datos MiniSEED**
        try:
            response = requests.get(osso_url, stream=True, timeout=500)

            if response.status_code != 200:
                print(f" Error {response.status_code} al descargar MiniSEED")
                return jsonify({"error": f"Error {response.status_code} al descargar MiniSEED."}), 500
            
            stream = read(io.BytesIO(response.content))
        except requests.exceptions.Timeout:
            print(" La solicitud a OSSO tard칩 demasiado y fue cancelada.")
            return jsonify({"error": "La solicitud a OSSO tard칩 demasiado."}), 504
        except requests.exceptions.RequestException as e:
            print(f" Error en la solicitud a OSSO: {e}")
            return jsonify({"error": f"Error en la solicitud a OSSO: {str(e)}"}), 500

        # 游늷 **10. Convertir fechas a `UTCDateTime` de obspy**
        start_utc = UTCDateTime(start_date.isoformat() + "Z")
        end_utc = UTCDateTime(end_date.isoformat() + "Z")

        # 游늷 **11. Recortar los datos**
        stream = stream.slice(starttime=start_utc, endtime=end_utc)
        trace = stream[0]

        # 游늷 **12. Graficar el sismograma**
        fig, ax = plt.subplots(figsize=(12, 6))
        ax.plot(trace.times("matplotlib"), trace.data, label=f"Canal {channel}", linewidth=0.8, color=color)
        ax.set_title(f"Sismograma {channel} ({trace.stats.station})", fontsize=12)
        ax.set_xlabel("Tiempo (HH:MM:SS UTC)", fontsize=10)
        ax.set_ylabel("Amplitud", fontsize=10)
        ax.legend(loc="upper right")
        ax.grid(True, linestyle="--", alpha=0.7)

        # 游늷 **13. Formatear el eje X para mostrar tiempos en UTC**
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S UTC'))

        # 游늷 **14. Mostrar la fecha en el gr치fico**
        date_str = start_date.strftime('%b-%d-%Y')
        plt.figtext(0.5, -0.05, f"Fecha: {date_str}", wrap=True, horizontalalignment='center', fontsize=12)

        # 游늷 **15. Guardar la imagen en memoria**
        output_image = io.BytesIO()
        plt.savefig(output_image, format='png', bbox_inches="tight")
        output_image.seek(0)
        plt.close(fig)

        # 游늷 **16. Enviar la imagen al usuario**
        return send_file(output_image, mimetype='image/png')

    except Exception as e:
        print(f"丘멆잺 Error general: {e}")
        return jsonify({"error": str(e)}), 500

# 游댳 **Ejecuci칩n en Google Cloud Run**
if __name__ == '__main__':
    port = int(os.environ.get("PORT", 8080))  # Cloud Run usa el puerto 8080 por defecto
    app.run(host='0.0.0.0', port=port)







